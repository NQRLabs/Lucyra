<!DOCTYPE html>
<html lang="en">
<head>
  <!--
    MIT License

    Copyright (c) 2025 NQR

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
  -->
    <!-- Favicons (browser tabs, bookmarks) -->
    <link rel="icon" type="image/png" sizes="32x32" href="assets/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/images/favicon-16x16.png">
    
    <!-- iOS & iPadOS (home screen icon when ï¿½Add to Home Screenï¿½) -->
    <link rel="apple-touch-icon" sizes="180x180" href="assets/images/apple-touch-icon-180x180.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucyra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        #control-panel {
            width: 320px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #00d4ff;
            box-shadow: 4px 0 20px rgba(0, 212, 255, 0.3);
        }

        #canvas {
            cursor: none;
            width: 100%;
            height: 100%;
            display: block;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        /* Right-side Info Panel */
        #info-panel {
            width: 320px;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #00d4ff;
            box-shadow: -4px 0 20px rgba(0, 212, 255, 0.3);
        }

        .info-section-title {
            font-size: 12px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 15px;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .info-text {
            font-size: 11px;
            line-height: 1.6;
            color: #b0b0b0;
            margin-bottom: 10px;
        }

        .method-name {
            font-size: 16px;
            color: #00ff88;
            font-weight: bold;
            text-align: center;
            padding: 8px;
            background: rgba(0, 212, 255, 0.08);
            border-radius: 6px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.35);
        }

        /* License modal styles (adapted to Lucyra palette) */
        .license-footer {
          margin-top: 30px;
          margin-bottom: 20px;
          padding: 10px 8px;
          font-size: 0.68rem;
          color: #a9a9b2;
          opacity: 0.7;
          cursor: pointer;
          transition: opacity 0.15s ease;
          text-align: center;
        }

        .license-footer:hover { opacity: 1; }

        .license-overlay {
          display: none; position: fixed; inset: 0;
          background: rgba(0,0,0,0.7); z-index: 999;
        }

        .license-modal {
          display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: #0f0f16; border: 2px solid rgba(0,212,255,0.35);
          border-radius: 12px; padding: 20px; max-width: 520px; width: 90%;
          max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,.6);
          z-index: 1000; text-align: center;
        }

        .license-modal.show, .license-overlay.show { display: block; }

        .license-modal-header {
          position: relative; display: flex; justify-content: center; align-items: center;
          padding-right: 32px; gap: 12px;
        }

        .license-modal-title { margin: 0; font-size: 1rem; text-align: center; width: 100%; color: #e0f7ff; }
        .license-modal-close { position: absolute; top: 0; right: 0; cursor: pointer; font-size: 1.5rem; color: #a9a9b2; line-height: 1; }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            justify-content: center;
            align-items: center;
            display: flex;
        }

        .tagline {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
            font-style: italic;
            justify-content: center;
            align-items: center;
            display: flex;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .param {
            margin: 8px 0;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
        }

        .param-label {
            color: #aaa;
        }

        .param-value {
            color: #00ff88;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #file-input {
            display: none;
        }

        canvas {
            image-rendering: crisp-edges;
        }

        canvas.dragging {
            cursor: grabbing !important;
        }

        canvas.draggable {
            cursor: grab;
        }

        .cursor-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #00d4ff;
            font-size: 13px;
            color: #00d4ff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cursor-hint.visible {
            opacity: 1;
        }

        .key {
            background: rgba(0, 212, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        #effect-name {
            font-size: 16px;
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }

        .preset-buttons button {
            font-size: 10px;
            padding: 8px;
        }

        #effect-index-input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            text-align: center;
            margin-top: 8px;
        }

        #effect-index-input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
        }

        #effect-index-input::placeholder {
            color: rgba(0, 212, 255, 0.4);
        }

        .help-link {
            display: block;
            text-align: center;
            color: #00d4ff;
            text-decoration: none;
            font-size: 14px;
            margin-top: 8px;
            padding: 5px;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .help-link:hover {
            opacity: 1;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="control-panel">
        <img src="assets/images/logo.png" alt="App Logo" class="app-logo" style="display:block; margin-left:auto; margin-right:auto; width:50%;">
        <h1>LUCYRA</h1>
        <div class="tagline">Illuminate the unseen</div>
        
        <div class="section">
            <button onclick="document.getElementById('file-input').click()">Load Image</button>
            <input type="file" id="file-input" accept="image/*">
        </div>

        <div class="section">
            <h3>Current Effect</h3>
            <div id="effect-name">No Effect</div>
            <div id="effect-params"></div>
            <input type="number" id="effect-index-input" placeholder="Jump to effect #" min="1">
        </div>

        <div class="section">
            <h3>Flashlight Properties</h3>
            <div class="param">
                <span class="param-label">Radius:</span>
                <span class="param-value" id="radius-value">150px</span>
            </div>
            <div class="param">
                <span class="param-label">Effect Index:</span>
                <span class="param-value" id="effect-index">0 / 0</span>
            </div>
            <div class="param">
                <span class="param-label">Zoom:</span>
                <span class="param-value" id="zoom-value">100%</span>
            </div>
        </div>

        <div class="section">
            <h3>Controls</h3>
            <div class="param" style="flex-direction: column; gap: 6px; font-size: 12px;">
                <div>
                  Try <span class="key">â†‘â†“</span>,
                <span class="key">Scroll</span>,
                <span class="key">Shift+Scroll</span>,
                <span class="key">Ctrl+Scroll</span>,
                <span class="key">Alt+Scroll</span>
                </div>
            </div>
            <a href="https://github.com/NQRLabs/Lucyra/" target="_blank" class="help-link">ðŸ“– View Documentation</a>
        </div>

        <div class="section">
            <h3>Presets</h3>
            <button onclick="app.savePreset()">Save Current State</button>
            <button onclick="app.loadPreset()">Load Saved State</button>
            <div class="preset-buttons">
                <button onclick="app.quickPreset(0)">Preset 1</button>
                <button onclick="app.quickPreset(1)">Preset 2</button>
                <button onclick="app.quickPreset(2)">Preset 3</button>
                <button onclick="app.quickPreset(3)">Preset 4</button>
            </div>
        </div>

        <div class="section">
            <button onclick="app.resetView()">Reset View</button>
            <button onclick="app.resetEffect()">Reset Effect</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="cursor-hint" id="hint">Load an image to begin analysis</div>
    </div>
    <div id="info-panel">
        <h1>INFO</h1>
        <div class="tagline">Filter Details</div>
        <div id="info-content" class="section">
            <p style="color: #888; font-size: 11px; text-align: center; font-style: italic;">
                Load an image and select an effect to see details
            </p>
        </div>
        <footer class="license-footer" id="licenseLink">MIT License &middot; Developed by NQR &middot; Click to view</footer>
    </div>

    <div class="license-overlay" id="licenseOverlay"></div>
    <div class="license-modal" id="licenseModal" role="dialog" aria-modal="true" aria-labelledby="licenseTitle">
      <div class="license-modal-header">
        <h3 class="license-modal-title" id="licenseTitle">MIT License</h3>
        <span class="license-modal-close" id="licenseClose" aria-label="Close license dialog">&times;</span>
      </div>
      <pre class="small-muted" style="text-align:center; white-space:pre-wrap; margin-top:14px; color:#a9a9b2;">
Copyright (c) 2025 NQR

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      </pre>
    </div>

    <script>
        const app = {
            canvas: null,
            ctx: null,
            originalImage: null,
            sourceCanvas: null,
            sourceCtx: null,
            sourceImageData: null,
            imageData: null,
            mouseX: 0,
            mouseY: 0,
            radius: 150,
            currentEffectIndex: 0,
            effects: [],
            isShiftPressed: false,
            isCtrlPressed: false,
            isAltPressed: false,
            animationFrame: null,
            quickPresets: [null, null, null, null],
            effectGroups: [], // Stores indices of last effect in each group
            cachedEffectedData: null,
            cachedEffectIndex: -1,
            
            // Info panel helpers
            getLightingInfo(effect) {
                const chNames = ['Red', 'Green', 'Blue'];
                const p = (effect && effect.params) || {};
                if (!effect) return { description: '', usage: '', params: '' };
                if (effect.apply === this.brightness) {
                    return { description: 'Uniformly boosts RGB intensities across the image.', usage: 'Good for coaxing out low-contrast payloads that sit just above noise. Diagnostic for testing dynamic range sensitivity: if hidden content strengthens as brightness increases, it likely modulates luminance slightly.', params: `Boost: ${p.boost ?? 'â€”'}x` };
                }
                if (effect.apply === this.contrast) {
                    return { description: 'Expands or compresses differences around mid-gray (global contrast).', usage: 'Enhances subtle luma modulations typical of local-contrast or high-frequency watermarks. Useful to diagnose whether the signal lives in luminance.', params: `Factor: ${p.factor ?? 'â€”'}` };
                }
                if (effect.apply === this.isolateChannel) {
                    return { description: 'Shows only one color channel; others are suppressed.', usage: 'Ideal for revealing single-channel or chroma-biased embeds (e.g., red-only nudges). Diagnostic for locating channel-specific anomalies.', params: `Channel: ${chNames[p.channel ?? 0]}` };
                }
                if (effect.apply === this.amplifyChannel) {
                    return { description: 'Multiplies one channel while leaving others unchanged.', usage: 'Boosts weak single-channel deviations to make chroma nudges or R/G/B imbalances visible.', params: `Channel: ${chNames[p.channel ?? 0]}, Factor: ${p.factor ?? 'â€”'}` };
                }
                if (effect.apply === this.invert) {
                    return { description: 'Inverts all channels (negative image).', usage: 'Sometimes exposes negative-going embeds or helps separate payload from background tone.', params: '' };
                }
                if (effect.apply === this.invertChannel) {
                    return { description: 'Inverts only the selected channel.', usage: 'Highlights asymmetric channel encodings by flipping one channel against the others.', params: `Channel: ${chNames[p.channel ?? 0]}` };
                }
                if (effect.apply === this.bitPlane) {
                    return { description: 'Extracts a specific bit from each pixel (bit-plane slicing).', usage: 'Directly elicits LSB-style steganography. If legible content emerges at a low bit-plane, LSB embedding is likely.', params: `Channel: ${chNames[p.channel ?? 0]}, Bit: ${p.bit ?? 'â€”'}` };
                }
                if (effect.apply === this.colorDifference) {
                    return { description: 'Shows the absolute difference between two color channels.', usage: 'Reveals chroma mismatches caused by color-biased embeds. Helpful for diagnosing channel coupling issues.', params: `Pair: ${chNames[p.ch1 ?? 0]} - ${chNames[p.ch2 ?? 1]}, Amplification: x${p.amp ?? 'â€”'}` };
                }
                if (effect.apply === this.gradientDetect) {
                    return { description: 'Computes gradient magnitude in a direction (H, V, or both).', usage: 'Elicits high-frequency payloads placed along edges or textures, common in edge/Laplacian-style watermarks.', params: `Direction: ${p.direction ?? 'both'}` };
                }
                if (effect.apply === this.aboveAverage) {
                    return { description: 'Keeps pixels brighter than the global average, scaled by a boost.', usage: 'Screens for bright outliers that may encode signals; quick anomaly detector for over-bright embeds.', params: `Boost: x${p.boost ?? 'â€”'}` };
                }
                if (effect.apply === this.belowAverage) {
                    return { description: 'Keeps pixels darker than the global average, scaled by a boost.', usage: 'Screens for dark outliers; useful for payloads that reduce luminance locally.', params: `Boost: x${p.boost ?? 'â€”'}` };
                }
                if (effect.apply === this.hueOnly) {
                    return { description: 'Visualizes hue while discarding luminance structure.', usage: 'Exposes hue-nudge steganography where brightness is preserved but color wheel shifts slightly.', params: '' };
                }
                if (effect.apply === this.saturationOnly) {
                    return { description: 'Maps saturation as intensity (grayscale).', usage: 'Highlights chroma modulation embeds that raise or lower saturation locally.', params: '' };
                }
                if (effect.apply === this.luminanceOnly) {
                    return { description: 'Shows luminance (perceptual brightness) alone.', usage: 'Useful to test if the signal lives primarily in the luma domain.', params: '' };
                }
                if (effect.apply === this.hueAmplified) {
                    return { description: 'Amplifies hue differences to exaggerate subtle color shifts.', usage: 'Coaxes out faint hue nudges used to hide payloads without brightness changes.', params: '' };
                }
                if (effect.apply === this.saturationAmplified) {
                    return { description: 'Amplifies saturation to magnify weak color-intensity changes.', usage: 'Brings out low-level chroma variations that might encode signal.', params: '' };
                }
                if (effect.apply === this.xorPattern) {
                    return { description: 'Applies a per-channel XOR with a constant mask.', usage: 'Can expose periodic/parity artifacts from certain arithmetic or binary encodings.', params: `Mask: ${p.value ?? 'â€”'}` };
                }
                if (effect.apply === this.edgeDetect) {
                    return { description: 'Edge magnitude via Sobel-like gradients across RGB.', usage: 'Elicits edge-anchored watermarks and high-frequency embeds; diagnostic for frequency placement.', params: `Threshold: ${p.threshold ?? 'â€”'}` };
                }
                if (effect.apply === this.posterize) {
                    return { description: 'Quantizes intensities into a small number of levels.', usage: 'Reveals clustered intensity steps indicative of LSB or quantization-based schemes.', params: `Levels: ${p.levels ?? 'â€”'}` };
                }
                if (effect.apply === this.modulo) {
                    return { description: 'Shows pixel values modulo N, re-scaled to full range.', usage: 'Can elicit repeating residues typical of arithmetic stego or compression side-effects.', params: `Modulo: ${p.value ?? 'â€”'}` };
                }
                if (effect.apply === this.threshold) {
                    return { description: 'Binarizes the image using a fixed threshold on brightness.', usage: 'Exposes binary-like payloads and cutoffs; quick way to separate signal from background.', params: `Threshold: ${p.value ?? 'â€”'}` };
                }
                if (effect.apply === this.gamma) {
                    return { description: 'Applies a gamma curve to remap tonal response.', usage: 'Probes shadow/highlight bias to expose embeds that prefer certain intensity ranges.', params: `Gamma: ${p.gamma ?? 'â€”'}` };
                }
                if (effect.apply === this.colorTemp) {
                    return { description: 'Shifts color temperature by nudging red/blue channels.', usage: 'Accentuates warm/cool residuals that may come from biased embeds.', params: `Temperature offset: ${p.temp ?? 'â€”'}` };
                }
                if (effect.apply === this.solarize) {
                    return { description: 'Inverts values above a threshold (solarization).', usage: 'Accentuates mid-to-high intensity anomalies; can reveal structured payloads.', params: `Level: ${p.level ?? 'â€”'}` };
                }
                return { description: 'Image filter used to probe for hidden information.', usage: 'Use as a diagnostic to amplify, isolate, or contrast features that may contain steganography.', params: '' };
            },

            updateInfoPanel() {
                const infoContent = document.getElementById('info-content');
                if (!infoContent) return;
                if (!this.effects || this.effects.length === 0) {
                    infoContent.innerHTML = `
                        <p style="color: #888; font-size: 11px; text-align: center; font-style: italic;">
                            Load an image and select an effect to see details
                        </p>`;
                    return;
                }
                const effect = this.effects[this.currentEffectIndex];
                const linfo = this.getLightingInfo(effect);
                const params = linfo.params ? `<div class="info-section-title">Parameters</div><div class="info-text">${linfo.params}</div>` : '';
                infoContent.innerHTML = `
                    <div class="method-name">${effect.name}</div>
                    <div class="info-section-title">What It Does</div>
                    <div class="info-text">${linfo.description}</div>
                    <div class="info-section-title">Forensics Use</div>
                    <div class="info-text">${linfo.usage}</div>
                    ${params}
                `;
            },
            
            // Zoom and pan state
            scale: 1.0,
            panX: 0,
            panY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            lastPanX: 0,
            lastPanY: 0,

            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.setupEffects();
                this.setupEventListeners();
                this.showHint('Load an image to begin analysis');
                const container = document.getElementById('canvas-container');
                this.canvas.width  = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.updateInfoPanel();
            },

            setupEffects() {
                const effects = [];

                // Brightness sweep (smooth gradations)
                for (let i = 0; i <= 10; i++) {
                    const boost = 0.5 + (i * 0.25);
                    effects.push({ name: `Brightness ${boost.toFixed(2)}x`, apply: this.brightness, params: { boost } });
                }

                // Contrast sweep
                for (let i = -8; i <= 12; i++) {
                    const factor = i * 0.5;
                    effects.push({ name: `Contrast ${factor.toFixed(1)}`, apply: this.contrast, params: { factor } });
                }

                // RGB Channel isolation with intensity variations
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let i = 1; i <= 5; i++) {
                        const factor = i * 0.5;
                        effects.push({ name: `${name} x${factor.toFixed(1)}`, apply: this.amplifyChannel, params: { channel: ch, factor } });
                    }
                }

                // Pure channel isolation
                effects.push({ name: 'Red Only', apply: this.isolateChannel, params: { channel: 0 } });
                effects.push({ name: 'Green Only', apply: this.isolateChannel, params: { channel: 1 } });
                effects.push({ name: 'Blue Only', apply: this.isolateChannel, params: { channel: 2 } });

                // Inverted variations
                effects.push({ name: 'Full Invert', apply: this.invert, params: {} });
                effects.push({ name: 'Invert Red', apply: this.invertChannel, params: { channel: 0 } });
                effects.push({ name: 'Invert Green', apply: this.invertChannel, params: { channel: 1 } });
                effects.push({ name: 'Invert Blue', apply: this.invertChannel, params: { channel: 2 } });

                // LSB visualization (all bits for each channel)
                for (const ch of [0, 1, 2]) {
                    const name = ['Red', 'Green', 'Blue'][ch];
                    for (let bit = 0; bit < 8; bit++) {
                        effects.push({ name: `${name} Bit ${bit}`, apply: this.bitPlane, params: { channel: ch, bit } });
                    }
                }

                // Color differences with amplification
                const pairs = [[0, 1, 'R-G'], [0, 2, 'R-B'], [1, 2, 'G-B']];
                for (const [ch1, ch2, label] of pairs) {
                    for (let i = 1; i <= 5; i++) {
                        const amp = i;
                        effects.push({ name: `${label} Diff x${amp}`, apply: this.colorDifference, params: { ch1, ch2, amp } });
                    }
                }

                // Gradient detection
                effects.push({ name: 'H-Gradient', apply: this.gradientDetect, params: { direction: 'horizontal' } });
                effects.push({ name: 'V-Gradient', apply: this.gradientDetect, params: { direction: 'vertical' } });
                effects.push({ name: 'All Gradients', apply: this.gradientDetect, params: { direction: 'both' } });

                // Statistical thresholding
                for (let i = 1; i <= 8; i++) {
                    const boost = i * 2;
                    effects.push({ name: `Above Avg x${boost}`, apply: this.aboveAverage, params: { boost } });
                }
                for (let i = 1; i <= 8; i++) {
                    const boost = i * 2;
                    effects.push({ name: `Below Avg x${boost}`, apply: this.belowAverage, params: { boost } });
                }

                // HSL components
                effects.push({ name: 'Hue Only', apply: this.hueOnly, params: {} });
                effects.push({ name: 'Saturation Only', apply: this.saturationOnly, params: {} });
                effects.push({ name: 'Luminance Only', apply: this.luminanceOnly, params: {} });
                effects.push({ name: 'Hue Amplified', apply: this.hueAmplified, params: {} });
                effects.push({ name: 'Saturation Amplified', apply: this.saturationAmplified, params: {} });

                // XOR patterns
                for (const val of [1, 3, 7, 15, 31, 63, 85, 127, 170, 255]) {
                    effects.push({ name: `XOR ${val}`, apply: this.xorPattern, params: { value: val } });
                }

                // Edge detection variations
                effects.push({ name: 'Edges Soft', apply: this.edgeDetect, params: { threshold: 0.5 } });
                effects.push({ name: 'Edges Normal', apply: this.edgeDetect, params: { threshold: 1.0 } });
                effects.push({ name: 'Edges Hard', apply: this.edgeDetect, params: { threshold: 1.5 } });

                // Posterization
                for (let levels = 2; levels <= 16; levels += 2) {
                    effects.push({ name: `Posterize ${levels}`, apply: this.posterize, params: { levels } });
                }

                // Modulo operations
                for (const mod of [2, 4, 8, 16, 32, 64, 128]) {
                    effects.push({ name: `Modulo ${mod}`, apply: this.modulo, params: { value: mod } });
                }

                // Threshold operations
                for (let thresh = 32; thresh <= 224; thresh += 32) {
                    effects.push({ name: `Threshold ${thresh}`, apply: this.threshold, params: { value: thresh } });
                }

                // Gamma correction
                for (let i = 1; i <= 9; i++) {
                    const gamma = i * 0.3;
                    effects.push({ name: `Gamma ${gamma.toFixed(1)}`, apply: this.gamma, params: { gamma } });
                }

                // Color temperature shifts
                for (let i = -5; i <= 5; i++) {
                    const temp = i * 20;
                    effects.push({ name: `Temp ${temp > 0 ? '+' : ''}${temp}`, apply: this.colorTemp, params: { temp } });
                }

                // Solarization
                for (let i = 1; i <= 5; i++) {
                    const level = i * 50;
                    effects.push({ name: `Solarize ${level}`, apply: this.solarize, params: { level } });
                }

                this.effects = effects;
                
                // Build effect groups (indices where parametric variations end)
                this.effectGroups = [0]; // Always include first effect
                let lastBaseName = '';
                for (let i = 0; i < effects.length; i++) {
                    const baseName = effects[i].name.replace(/[\d.+\-x]+/g, '').trim();
                    if (baseName !== lastBaseName && lastBaseName !== '') {
                        this.effectGroups.push(i);
                    }
                    lastBaseName = baseName;
                }
                
                this.updateEffectDisplay();
                this.updateInfoPanel();
            },

            setupEventListeners() {
                const fileInput = document.getElementById('file-input');
                fileInput.addEventListener('change', (e) => this.loadImage(e));

                // Effect index input
                const effectInput = document.getElementById('effect-index-input');
                effectInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const value = parseInt(effectInput.value);
                        if (value >= 1 && value <= this.effects.length) {
                            this.currentEffectIndex = value - 1;
                            this.updateEffectDisplay();
                            this.updateInfoPanel();
                            this.render();
                        }
                        effectInput.value = '';
                        effectInput.blur();
                    }
                });

                const container = document.getElementById('canvas-container');
                
                container.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                container.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                container.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                container.addEventListener('mouseleave', () => this.handleMouseLeave());
                container.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift') this.isShiftPressed = true;
                    if (e.key === 'Control') this.isCtrlPressed = true;
                    if (e.key === 'Alt') this.isAltPressed = true;
                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        // After inverting scroll direction, ArrowUp should still advance effects
                        this.handleWheel({ deltaY: 100, shiftKey: this.isShiftPressed, ctrlKey: this.isCtrlPressed, altKey: this.isAltPressed });
                    }
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.handleWheel({ deltaY: -100, shiftKey: this.isShiftPressed, ctrlKey: this.isCtrlPressed, altKey: this.isAltPressed });
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') this.isShiftPressed = false;
                    if (e.key === 'Control') this.isCtrlPressed = false;
                    if (e.key === 'Alt') this.isAltPressed = false;
                });

                window.addEventListener('resize', () => this.resizeCanvas());
            },

            loadImage(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        // Prepare native-resolution source canvas/data
                        this.sourceCanvas = document.createElement('canvas');
                        this.sourceCanvas.width = img.width;
                        this.sourceCanvas.height = img.height;
                        this.sourceCtx = this.sourceCanvas.getContext('2d', { willReadFrequently: true });
                        this.sourceCtx.drawImage(img, 0, 0);
                        this.sourceImageData = this.sourceCtx.getImageData(0, 0, img.width, img.height);
                        this.scale = 1.0;
                        this.panX = 0;
                        this.panY = 0;
                        this.resizeCanvas();
                        this.drawOriginal();
                        this.showHint('Move mouse over image to reveal hidden data', 3000);
                        this.updateInfoPanel();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            },


            resizeCanvas() {
              const container = document.getElementById('canvas-container');
            
              // Always make the canvas match the available space on the right
              this.canvas.width  = container.clientWidth;
              this.canvas.height = container.clientHeight;
            
              if (!this.originalImage) return;
            
              // Compute a "contain" rectangle for the image inside the full-size canvas
              const imgW = this.originalImage.width;
              const imgH = this.originalImage.height;
              const imgAspect = imgW / imgH;
              const canvasAspect = this.canvas.width / this.canvas.height;
            
              if (imgAspect > canvasAspect) {
                // Fit width, center vertically
                this.drawW = this.canvas.width;
                this.drawH = Math.round(this.drawW / imgAspect);
                this.drawX = 0;
                this.drawY = Math.floor((this.canvas.height - this.drawH) / 2);
              } else {
                // Fit height, center horizontally
                this.drawH = this.canvas.height;
                this.drawW = Math.round(this.drawH * imgAspect);
                this.drawY = 0;
                this.drawX = Math.floor((this.canvas.width - this.drawW) / 2);
              }
            
              this.drawOriginal();
            },

            drawOriginal() {
              if (!this.originalImage) return;
            
              this.ctx.setTransform(1, 0, 0, 1, 0, 0);
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
              // Optional: fill background to avoid transparent areas
              this.ctx.fillStyle = '#000';
              this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            
              // Draw the image into the full-size canvas using the contain rect
              this.ctx.drawImage(this.originalImage, this.drawX, this.drawY, this.drawW, this.drawH);
            
              // Cache the full-canvas pixels for your effects pipeline
              this.imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
              
              // Invalidate effect cache
              this.cachedEffectedData = null;
              this.cachedEffectIndex = -1;
            },

            handleMouseDown(e) {
                if (e.button === 0) { // Left click
                    this.isDragging = true;
                    this.dragStartX = e.clientX;
                    this.dragStartY = e.clientY;
                    this.lastPanX = this.panX;
                    this.lastPanY = this.panY;
                    this.canvas.classList.add('dragging');
                    this.canvas.classList.remove('draggable');
                }
            },

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                
                if (this.isDragging) {
                    // Pan the image
                    const dx = e.clientX - this.dragStartX;
                    const dy = e.clientY - this.dragStartY;
                    this.panX = this.lastPanX + dx;
                    this.panY = this.lastPanY + dy;
                    this.render();
                } else {
                    // Transform mouse coordinates to canvas space accounting for zoom and pan
                    const canvasCenterX = this.canvas.width / 2;
                    const canvasCenterY = this.canvas.height / 2;
                    
                    const mouseCanvasX = e.clientX - rect.left;
                    const mouseCanvasY = e.clientY - rect.top;
                    
                    // Convert to image space
                    this.mouseX = (mouseCanvasX - canvasCenterX - this.panX) / this.scale + canvasCenterX;
                    this.mouseY = (mouseCanvasY - canvasCenterY - this.panY) / this.scale + canvasCenterY;
                    
                    this.render();
                    
                    if (!this.canvas.classList.contains('dragging')) {
                        this.canvas.classList.add('draggable');
                    }
                }
            },

            handleMouseUp(e) {
                this.isDragging = false;
                this.canvas.classList.remove('dragging');
                this.canvas.classList.add('draggable');
            },

            handleMouseLeave() {
                this.isDragging = false;
                this.drawOriginal();
                this.canvas.classList.remove('dragging');
                this.canvas.classList.remove('draggable');
            },

            handleWheel(e) {
                if (e.preventDefault) e.preventDefault();

                if (e.ctrlKey || this.isCtrlPressed) {
                    // Zoom
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.max(0.1, Math.min(10, this.scale * zoomFactor));
                    
                    // Zoom towards mouse position
                    const canvasCenterX = this.canvas.width / 2;
                    const canvasCenterY = this.canvas.height / 2;
                    
                    const mouseOffsetX = mouseX - canvasCenterX - this.panX;
                    const mouseOffsetY = mouseY - canvasCenterY - this.panY;
                    
                    this.panX = this.panX + mouseOffsetX * (1 - newScale / this.scale);
                    this.panY = this.panY + mouseOffsetY * (1 - newScale / this.scale);
                    
                    this.scale = newScale;
                    document.getElementById('zoom-value').textContent = Math.round(this.scale * 100) + '%';
                    this.render();
                } else if (e.altKey || this.isAltPressed) {
                    // Jump between effect groups (inverted scroll direction)
                    const direction = e.deltaY > 0 ? -1 : 1;
                    
                    // Find current group
                    let currentGroup = 0;
                    for (let i = 0; i < this.effectGroups.length; i++) {
                        if (this.currentEffectIndex < this.effectGroups[i]) {
                            currentGroup = i - 1;
                            break;
                        }
                    }
                    if (this.currentEffectIndex >= this.effectGroups[this.effectGroups.length - 1]) {
                        currentGroup = this.effectGroups.length - 1;
                    }
                    
                    // Jump to next/previous group
                    const nextGroup = (currentGroup + direction + this.effectGroups.length) % this.effectGroups.length;
                    this.currentEffectIndex = this.effectGroups[nextGroup];
                    this.updateEffectDisplay();
                    this.updateInfoPanel();
                    this.render();
                } else if (e.shiftKey || this.isShiftPressed) {
                    // Adjust radius
                    const delta = e.deltaY > 0 ? -10 : 10;
                    this.radius = Math.max(20, Math.min(500, this.radius + delta));
                    document.getElementById('radius-value').textContent = this.radius + 'px';
                    this.render();
                } else {
                    // Cycle effects (inverted scroll direction)
                    const delta = e.deltaY > 0 ? -1 : 1;
                    this.currentEffectIndex = (this.currentEffectIndex + delta + this.effects.length) % this.effects.length;
                    this.updateEffectDisplay();
                    this.updateInfoPanel();
                    this.render();
                }
            },

            render() {
                if (!this.imageData) return;

                // Clear and set transform
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and pan
                const canvasCenterX = this.canvas.width / 2;
                const canvasCenterY = this.canvas.height / 2;
                this.ctx.translate(canvasCenterX + this.panX, canvasCenterY + this.panY);
                this.ctx.scale(this.scale, this.scale);
                this.ctx.translate(-canvasCenterX, -canvasCenterY);

                // Draw base image
                this.ctx.putImageData(this.imageData, 0, 0);

                // Cache effected data if effect hasn't changed
                const effect = this.effects[this.currentEffectIndex];
                if (!this.cachedEffectedData || this.cachedEffectIndex !== this.currentEffectIndex) {
                    // 1) Apply effect at native image resolution to preserve bit-planes
                    const srcW = (this.sourceCanvas && this.sourceCanvas.width) || (this.originalImage ? this.originalImage.width : this.canvas.width);
                    const srcH = (this.sourceCanvas && this.sourceCanvas.height) || (this.originalImage ? this.originalImage.height : this.canvas.height);

                    const nativeCanvas = document.createElement('canvas');
                    nativeCanvas.width = srcW;
                    nativeCanvas.height = srcH;
                    const nctx = nativeCanvas.getContext('2d', { willReadFrequently: true });
                    if (this.sourceImageData) {
                        nctx.putImageData(this.sourceImageData, 0, 0);
                    } else if (this.originalImage) {
                        nctx.drawImage(this.originalImage, 0, 0);
                    } else {
                        nctx.drawImage(this.canvas, 0, 0);
                    }

                    let nativeData = nctx.getImageData(0, 0, srcW, srcH);
                    const params = { ...effect.params, workingWidth: srcW, workingHeight: srcH };
                    effect.apply.call(this, nativeData.data, params);
                    nctx.putImageData(nativeData, 0, 0);

                    // 2) Scale effected native result into a full-canvas buffer aligned to the image placement
                    const scaledCanvas = document.createElement('canvas');
                    scaledCanvas.width = this.canvas.width;
                    scaledCanvas.height = this.canvas.height;
                    const sctx = scaledCanvas.getContext('2d', { willReadFrequently: true });
                    sctx.fillStyle = '#000';
                    sctx.fillRect(0, 0, scaledCanvas.width, scaledCanvas.height);
                    // Draw effected image into its displayed rect
                    const drawX = this.drawX || 0;
                    const drawY = this.drawY || 0;
                    const drawW = this.drawW || this.canvas.width;
                    const drawH = this.drawH || this.canvas.height;
                    sctx.drawImage(nativeCanvas, drawX, drawY, drawW, drawH);

                    this.cachedEffectedData = sctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                    this.cachedEffectIndex = this.currentEffectIndex;
                }

                const effectedData = this.cachedEffectedData;
                const finalData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                
                // Optimized: only process pixels within bounding box
                const minX = Math.max(0, Math.floor(this.mouseX - this.radius));
                const maxX = Math.min(this.canvas.width, Math.ceil(this.mouseX + this.radius));
                const minY = Math.max(0, Math.floor(this.mouseY - this.radius));
                const maxY = Math.min(this.canvas.height, Math.ceil(this.mouseY + this.radius));
                const radiusSquared = this.radius * this.radius;
                
                // Apply radial gradient blend centered on mouse position
                for (let y = minY; y < maxY; y++) {
                    for (let x = minX; x < maxX; x++) {
                        const i = (y * this.canvas.width + x) * 4;
                        
                        const dx = x - this.mouseX;
                        const dy = y - this.mouseY;
                        const distanceSquared = dx * dx + dy * dy;
                        
                        if (distanceSquared <= radiusSquared) {
                            const distance = Math.sqrt(distanceSquared);
                            const normalized = distance / this.radius;
                            const alpha = 1 - (normalized * normalized);
                            
                            finalData.data[i] = effectedData.data[i] * alpha + this.imageData.data[i] * (1 - alpha);
                            finalData.data[i + 1] = effectedData.data[i + 1] * alpha + this.imageData.data[i + 1] * (1 - alpha);
                            finalData.data[i + 2] = effectedData.data[i + 2] * alpha + this.imageData.data[i + 2] * (1 - alpha);
                        }
                    }
                }

                // Reset transform, draw final result, then reapply transform
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = this.canvas.width;
                finalCanvas.height = this.canvas.height;
                const finalCtx = finalCanvas.getContext('2d');
                finalCtx.putImageData(finalData, 0, 0);
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.translate(canvasCenterX + this.panX, canvasCenterY + this.panY);
                this.ctx.scale(this.scale, this.scale);
                this.ctx.translate(-canvasCenterX, -canvasCenterY);
                this.ctx.drawImage(finalCanvas, 0, 0);
                
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            },

            // Effect implementations
            brightness(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * params.boost);
                    data[i + 1] = Math.min(255, data[i + 1] * params.boost);
                    data[i + 2] = Math.min(255, data[i + 2] * params.boost);
                }
            },

            contrast(data, params) {
                const factor = params.factor;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.max(0, Math.min(255, (data[i] - 128) * factor + 128));
                    data[i + 1] = Math.max(0, Math.min(255, (data[i + 1] - 128) * factor + 128));
                    data[i + 2] = Math.max(0, Math.min(255, (data[i + 2] - 128) * factor + 128));
                }
            },

            isolateChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const value = data[i + params.channel];
                    data[i] = params.channel === 0 ? value : 0;
                    data[i + 1] = params.channel === 1 ? value : 0;
                    data[i + 2] = params.channel === 2 ? value : 0;
                }
            },

            amplifyChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + params.channel] = Math.min(255, data[i + params.channel] * params.factor);
                }
            },

            invert(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
            },

            invertChannel(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i + params.channel] = 255 - data[i + params.channel];
                }
            },

            bitPlane(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const bit = (data[i + params.channel] >> params.bit) & 1;
                    const value = bit * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            colorDifference(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const diff = Math.min(255, Math.abs(data[i + params.ch1] - data[i + params.ch2]) * params.amp);
                    data[i] = diff;
                    data[i + 1] = diff;
                    data[i + 2] = diff;
                }
            },

            gradientDetect(data, params) {
                const width  = (params && params.workingWidth)  || this.canvas.width;
                const height = (params && params.workingHeight) || this.canvas.height;
                const tempData = new Uint8ClampedArray(data);

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        let gx = 0, gy = 0;

                        if (params.direction === 'horizontal' || params.direction === 'both') {
                            const left = (y * width + x - 1) * 4;
                            const right = (y * width + x + 1) * 4;
                            gx = Math.abs(tempData[right] - tempData[left]);
                        }

                        if (params.direction === 'vertical' || params.direction === 'both') {
                            const top = ((y - 1) * width + x) * 4;
                            const bottom = ((y + 1) * width + x) * 4;
                            gy = Math.abs(tempData[bottom] - tempData[top]);
                        }

                        const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy) * 2);
                        data[i] = magnitude;
                        data[i + 1] = magnitude;
                        data[i + 2] = magnitude;
                    }
                }
            },

            aboveAverage(data, params) {
                let sum = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                const avg = sum / (data.length / 4);

                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const diff = brightness > avg ? (brightness - avg) * params.boost : 0;
                    data[i] = Math.min(255, diff);
                    data[i + 1] = Math.min(255, diff);
                    data[i + 2] = Math.min(255, diff);
                }
            },

            belowAverage(data, params) {
                let sum = 0;
                for (let i = 0; i < data.length; i += 4) {
                    sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
                }
                const avg = sum / (data.length / 4);

                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const diff = brightness < avg ? (avg - brightness) * params.boost : 0;
                    data[i] = Math.min(255, diff);
                    data[i + 1] = Math.min(255, diff);
                    data[i + 2] = Math.min(255, diff);
                }
            },

            hueOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], 1, 0.5);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            saturationOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const value = hsl[1] * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            luminanceOnly(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const value = hsl[2] * 255;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            hueAmplified(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], Math.min(1, hsl[1] * 2), hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            saturationAmplified(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const hsl = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
                    const rgb = this.hslToRgb(hsl[0], Math.min(1, hsl[1] * 3), hsl[2]);
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                }
            },

            xorPattern(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = data[i] ^ params.value;
                    data[i + 1] = data[i + 1] ^ params.value;
                    data[i + 2] = data[i + 2] ^ params.value;
                }
            },

            edgeDetect(data, params) {
                const width  = (params && params.workingWidth)  || this.canvas.width;
                const height = (params && params.workingHeight) || this.canvas.height;
                const tempData = new Uint8ClampedArray(data);

                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = (y * width + x) * 4;
                        
                        let gx = 0, gy = 0;
                        for (let c = 0; c < 3; c++) {
                            gx += -tempData[((y - 1) * width + x - 1) * 4 + c] +
                                   tempData[((y - 1) * width + x + 1) * 4 + c] +
                                  -2 * tempData[(y * width + x - 1) * 4 + c] +
                                   2 * tempData[(y * width + x + 1) * 4 + c] +
                                  -tempData[((y + 1) * width + x - 1) * 4 + c] +
                                   tempData[((y + 1) * width + x + 1) * 4 + c];
                            
                            gy += -tempData[((y - 1) * width + x - 1) * 4 + c] +
                                  -2 * tempData[((y - 1) * width + x) * 4 + c] +
                                  -tempData[((y - 1) * width + x + 1) * 4 + c] +
                                   tempData[((y + 1) * width + x - 1) * 4 + c] +
                                   2 * tempData[((y + 1) * width + x) * 4 + c] +
                                   tempData[((y + 1) * width + x + 1) * 4 + c];
                        }

                        const magnitude = Math.min(255, Math.sqrt(gx * gx + gy * gy) * params.threshold / 3);
                        data[i] = magnitude;
                        data[i + 1] = magnitude;
                        data[i + 2] = magnitude;
                    }
                }
            },

            posterize(data, params) {
                const step = 256 / params.levels;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.floor(data[i] / step) * step;
                    data[i + 1] = Math.floor(data[i + 1] / step) * step;
                    data[i + 2] = Math.floor(data[i + 2] / step) * step;
                }
            },

            modulo(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = (data[i] % params.value) * (255 / params.value);
                    data[i + 1] = (data[i + 1] % params.value) * (255 / params.value);
                    data[i + 2] = (data[i + 2] % params.value) * (255 / params.value);
                }
            },

            threshold(data, params) {
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const value = brightness > params.value ? 255 : 0;
                    data[i] = value;
                    data[i + 1] = value;
                    data[i + 2] = value;
                }
            },

            gamma(data, params) {
                const gamma = params.gamma;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.pow(data[i] / 255, gamma) * 255;
                    data[i + 1] = Math.pow(data[i + 1] / 255, gamma) * 255;
                    data[i + 2] = Math.pow(data[i + 2] / 255, gamma) * 255;
                }
            },

            colorTemp(data, params) {
                const temp = params.temp;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.max(0, Math.min(255, data[i] + temp));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] - temp));
                }
            },

            solarize(data, params) {
                const level = params.level;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] > level) data[i] = 255 - data[i];
                    if (data[i + 1] > level) data[i + 1] = 255 - data[i + 1];
                    if (data[i + 2] > level) data[i + 2] = 255 - data[i + 2];
                }
            },

            // Color space helpers
            rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h, s, l];
            },

            hslToRgb(h, s, l) {
                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            },

            updateEffectDisplay() {
                const effect = this.effects[this.currentEffectIndex];
                document.getElementById('effect-name').textContent = effect.name;
                document.getElementById('effect-index').textContent = `${this.currentEffectIndex + 1} / ${this.effects.length}`;

                const paramsDiv = document.getElementById('effect-params');
                paramsDiv.innerHTML = '';
                for (const [key, value] of Object.entries(effect.params)) {
                    const paramDiv = document.createElement('div');
                    paramDiv.className = 'param';
                    const displayValue = typeof value === 'number' ? value.toFixed(2) : value;
                    paramDiv.innerHTML = `
                        <span class="param-label">${key}:</span>
                        <span class="param-value">${displayValue}</span>
                    `;
                    paramsDiv.appendChild(paramDiv);
                }
            },

            savePreset() {
                const state = {
                    effectIndex: this.currentEffectIndex,
                    radius: this.radius,
                    scale: this.scale,
                    panX: this.panX,
                    panY: this.panY
                };
                localStorage.setItem('lucyra_preset', JSON.stringify(state));
                this.showHint('State saved!', 2000);
            },

            loadPreset() {
                const saved = localStorage.getItem('lucyra_preset');
                if (saved) {
                    const state = JSON.parse(saved);
                    this.currentEffectIndex = state.effectIndex;
                    this.radius = state.radius;
                    this.scale = state.scale || 1.0;
                    this.panX = state.panX || 0;
                    this.panY = state.panY || 0;
                    this.updateEffectDisplay();
                    this.updateInfoPanel();
                    document.getElementById('radius-value').textContent = this.radius + 'px';
                    document.getElementById('zoom-value').textContent = Math.round(this.scale * 100) + '%';
                    this.render();
                    this.showHint('State loaded!', 2000);
                } else {
                    this.showHint('No saved state found', 2000);
                }
            },

            quickPreset(slot) {
                if (this.quickPresets[slot]) {
                    const state = this.quickPresets[slot];
                    this.currentEffectIndex = state.effectIndex;
                    this.radius = state.radius;
                    this.scale = state.scale || 1.0;
                    this.panX = state.panX || 0;
                    this.panY = state.panY || 0;
                    this.updateEffectDisplay();
                    this.updateInfoPanel();
                    document.getElementById('radius-value').textContent = this.radius + 'px';
                    document.getElementById('zoom-value').textContent = Math.round(this.scale * 100) + '%';
                    this.render();
                    this.showHint(`Preset ${slot + 1} loaded!`, 2000);
                } else {
                    this.quickPresets[slot] = {
                        effectIndex: this.currentEffectIndex,
                        radius: this.radius,
                        scale: this.scale,
                        panX: this.panX,
                        panY: this.panY
                    };
                    this.showHint(`Preset ${slot + 1} saved!`, 2000);
                }
            },

            resetView() {
                this.scale = 1.0;
                this.panX = 0;
                this.panY = 0;
                document.getElementById('zoom-value').textContent = '100%';
                this.render();
                this.showHint('View reset!', 2000);
            },

            resetEffect() {
                this.currentEffectIndex = 0;
                this.radius = 150;
                this.updateEffectDisplay();
                this.updateInfoPanel();
                document.getElementById('radius-value').textContent = this.radius + 'px';
                this.drawOriginal();
            },

            showHint(text, duration = 0) {
                const hint = document.getElementById('hint');
                hint.textContent = text;
                hint.classList.add('visible');

                if (duration > 0) {
                    setTimeout(() => {
                        hint.classList.remove('visible');
                    }, duration);
                }
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
    <script>
      // License modal controls (shared with both panels)
      function openLicense() {
        document.getElementById('licenseOverlay').classList.add('show');
        document.getElementById('licenseModal').classList.add('show');
      }
      function closeLicense() {
        document.getElementById('licenseOverlay').classList.remove('show');
        document.getElementById('licenseModal').classList.remove('show');
      }
      window.addEventListener('DOMContentLoaded', () => {
        const link = document.getElementById('licenseLink');
        const overlay = document.getElementById('licenseOverlay');
        const closeX = document.getElementById('licenseClose');
        if (link) link.addEventListener('click', openLicense);
        if (overlay) overlay.addEventListener('click', closeLicense);
        if (closeX) closeX.addEventListener('click', closeLicense);
      });
    </script>
</body>
</html>

